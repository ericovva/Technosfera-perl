
=head1 DESCRIPTION
Эта функция должна принять на вход арифметическое выражение,
а на выходе дать ссылку на массив, состоящий из отдельных токенов.
Токен - это отдельная логическая часть выражения: число, скобка или арифметическая операция
В случае ошибки в выражении функция должна вызывать die с сообщением об ошибке
Знаки '-' и '+' в первой позиции, или после другой арифметической операции стоит воспринимать
как унарные и можно записывать как "U-" и "U+"
Стоит заметить, что после унарного оператора нельзя использовать бинарные операторы
Например последовательность 1 + - / 2 невалидна. Бинарный оператор / идёт после использования унарного "-"
=cut

use 5.010;
use strict;
use warnings;
use Data::Dumper;
use diagnostics;
BEGIN{
	if ($] < 5.018) {
		package experimental;
		use warnings::register;
	}
}
no warnings 'experimental';
sub isNum {
	chomp(my $check = shift);
	return ($check =~/[0-9]/);
}
sub isBalance {
	chomp(my $check = shift);
	my @arr = split //, $check;
	my $balance = 0;
	for (my $i = 0; $i < scalar(@arr); $i++) {
		if ($arr[$i] eq "(") {
			$balance++;
		} elsif ($arr[$i] eq ")") {
			$balance--;
		}
		if ($balance < 0) {
			return 0;
		}
	}
	return !(!!$balance); 
	#!! = 0, если был 0, и 1 если был не 0, третье даст наоборот
}
sub tokenize {
	chomp(my $expr = shift);
	my @res_ = ();
	my @res = ();
	$expr = "(".$expr;
	$expr .= ")";
	if (!isBalance($expr)) {
		die "Неправильный баланс скобок";
	}
	$expr=~s/(\s)+/ /g; #оставить только один пробел из повторения
	#есть место вида "(выражение)|ничего|выражение")
	if ($expr =~s/(\d)\s(\d)//g) {
		#num an num
		die "Нет операций между выражениями ".$1. " и ".$2."\n";
	} elsif ($expr =~s/(\([0-9\s\*\+\-\/\^]*\))\s?(\([0-9\s\*\+\-\/\^]*\))//g) {
		#(...) (...)
		die "Нет операций между выражениями ".$1." и ".$2."\n";
	} elsif ($expr =~s/(\d+)\s?(\([0-9\s\*\+\-\/\^]*\))//g) {
		#число и скобки
		die "Нет операций между выражениями ".$1." и ".$2."\n";
	} elsif ($expr =~s/(\([0-9\s\*\+\-\/\^]*\))\s?(\d+)//g) {
		#скобки и число
		die "Нет операций между выражениями ".$1." и ".$2."\n";
	} #elsif ($expr =~s/([\+\-\*\^\/])\s?(\))//g) {
		#
		#die "Нет операндов ".$1." и ".$2;
	#}
	$expr =~s/\s//g;
	if ($expr =~/[^0-9\+\-\(\)\^\*\/\s]/) {
		die "Недопустимые символы";
	}
	@res_ = split //, $expr; #по символьно
	#соеденим все цифры
	push (@res, $res_[0]);
	for (my $i = 1; $i < scalar(@res_); $i++) {
		if (isNum($res_[$i]) && isNum($res_[$i - 1])) {
			my $temp = pop @res;
			$temp *= 10;
			$temp += $res_[$i];
			push @res, $temp;
		} else {
			push @res, $res_[$i];
		}
	}
	@res_ = ();
	push (@res_, "(");
	for (my $i = 1; $i < scalar(@res); $i++) {
		my $pr = $res[$i - 1];
		my $cur = $res[$i];
		push(@res_, $cur);
		if ($cur eq '+' || $cur eq '-') {
			if ($pr eq '^' || $pr eq '+' || $pr eq '-' || $pr eq '*' || $pr eq '/' || $pr eq '(') {
				#унарный оператор
				$res_[$i] = "U".$cur;
			}
		}
	}
	@res = @res_;
	#print(Dumper(@res));
	for (my $i = 1; $i < scalar(@res) - 1; $i++) {
		#смотрим, верные ли операнды у бинарных операций
		if ($res[$i] !~/[^\+\-\*\/\^]/) {
			if ($res[$i - 1] =~/([^\d+\)])/) {
				die "Неверный операнд: \"".$1."\" перед ".$res[$i];
			}
			if ($res[$i + 1] =~/([^\d+|\(|U\+|U\-])/) {
				die "Неверный операнд: \"".$1."\" после ".$res[$i];
			}
		}
		#верные ли операнды у унарных операций
		if ($res[$i] =~/U[\+\-]/) {
			if ($res[$i + 1] =~/([^\d+|\(|U\+|U\-])/) {
				die "Неверный операнд: \"".$1."\" после ".$res[$i];
			}
		}
	}
	return \@res;
}
#no operastion between operands

#tokenize("(-1*-1)");
#tokenize("(-4-)");
1;
